<template><p>After customers started using Event Store Cloud, we began receiving questions about migrating their existing databases to the cloud. Back then, we didn't have an answer to that question, although we expected it.</p>
<p>When talking to customers daily, we understand that each customer case is unique. Still, we have a set of attributes that allow us to find out the best solution if it's available. Those attributes are, for example:</p>
<ul>
<li>The database size, which could be large (several terabytes) or relatively small</li>
<li>The number of unscavenged events, which could be, for example, stats events</li>
<li>The number of unnecessary events that aren't explicitly deleted but are also not needed</li>
</ul>
<p>For large databases, where all the data must be migrated, it's not easy to create a realistic live migration scenario. Currently, live migration can only be done by reading events from the source database (from <code>$all</code>) using a client protocol and then writing those events to the target database. When there's a requirement to keep the order of events intact, events must be written to the target database one by one, as EventStoreDB doesn't support multi-stream transactional writes. Then, we hit the limitation of how fast a single write can go and multiply it by the number of events to copy. If it takes 5 ms to write one event, it's impossible to go beyond copying more than 250 events per second, keeping the global order. It gives us an idea of how fast (or slow) one can copy a larger database. For example, 1 million events would be replicated in an hour, and 100 million events would take more than four days to copy.</p>
<p>Another issue to consider is that if the source database still gets new writes during the live migration, the speed of the copying process needs to exceed the rate at which new events get added to the source database. For example, if you copy 250 events per second and append 250 events per second to the source, the copying process will not move forward the slightest bit.</p>
<p>With all those limitations in mind, we still have a demand to migrate mid- to small-size databases with some millions of events. As I mentioned previously, we see cases when customers have accumulated numerous deleted and useless events, which can be ignored during the migration. Since the speed of appending new events to the target database is the apparent bottleneck, the fewer events we need to copy, the faster the migration will complete.</p>
<p>In addition, we keep getting questions about tooling that could help solve one of the most troublesome issues of production event-sourced systems, which is the event schema versioning and migration. In his book &quot;Versioning in an Event Sourced System&quot;, Greg Young promotes the idea that all the data can be migrated from one store to another as part of the new software version deployment process. Of course, again, it very much depends on the database size. It's not feasible to migrate a few terabytes of data for each release when you do a few releases per week. Then again, not all systems are like that. A vast majority of business applications that use EventStoreDB as an event store have much smaller databases. However, such a migration requires tooling, which we never provided. Until today!</p>
<p>Meet Event Store Replicator, the tool that you can use for the following scenarios:</p>
<ul>
<li>Live migration of EventStoreDB from on-premises to Event Store Cloud</li>
<li>Replicating data between two EventStoreDB clusters, no matter where they are hosted</li>
<li>Filter events by stream name and event type during the migration</li>
<li>Filter out events, which should've been scavenged</li>
<li>Transform events, including stream name or event type change, change the event schema and data, or even enrich events using external data sources</li>
</ul>
<p>The replicator can use both TCP and gRPC protocol for both source and target so that you can replicate between different EventStoreDB versions.</p>
<p>The replication process looks like this:</p>
<p><img src="@source/resources/articles/images/replicator/replicator-1.svg" alt="Overview"></p>
<p>Internally, we separated each step into its own pipe, then connected all the pipes together:</p>
<p><img src="@source/resources/articles/images/replicator/replicator-2.svg" alt="Overview"></p>
<p>Both prepare and sink pipe have buffers, which allows us to balance the performance of those steps, so they don't depend so much on each other. It's not usual that the prepare pipe uses more time compared to the sink pipe. However, it might be the case if you use the externalised HTTP event transformation.</p>
<p>When it comes to writing events to the sink, we have two options. The default option is to use a single writer, so all the events get written to the target cluster one by one, maintaining the original global order of events of the source cluster. The other option is to <a href="https://replicator.eventstore.org/docs/features/sinks/writers/" target="_blank" rel="noopener noreferrer">partition writes<OutboundLink/></a> by stream name. In this case, the global order can't be maintained, but all the events in each individual stream would be appended in order. Partitioned sink allows increasing the number of writers, which run in parallel. As a result, the overall performance of the replication process increases significantly. For example, on the same cluster that uses 5 ms on average for a single write, increasing the number of writers to six increases the overall performance from 250 to 1000 events per second.</p>
<p>Within the prepare pipe, we first execute filters. The default filter is what we call a &quot;scavenge filter&quot;. It filters out events, which were previously deleted, but remain in the database for some reason. During the replication, we also listen to stream metadata updates that happen in real-time and react accordingly. For example, if you delete a stream after the replication has started, we won't replicate any more events from that stream. Eventually, the replication process will reach the metadata event in $all and will remove the stream in the target cluster if it exists.</p>
<p>The next step in the prepare pipe is event transformation. The default transformer just uses the original event as-is, with one addition. If the event is serialised to JSON, we will add these fields to metadata:</p>
<ul>
<li><code>$originalCreatedDate</code></li>
<li><code>$originalEventNumber</code></li>
<li><code>$originalEventPosition</code></li>
</ul>
<p>We included two additional transformers to the tool, which give you more flexibility. The first one is the JavaScript stateless transform that allows you to change the event type and stream and manipulate the event schema, data and metadata. You need to write your own JavaScript function to do this. If the function returns nothing, we will not replicate the event, so you can use <a href="https://replicator.eventstore.org/docs/features/transforms/js/" target="_blank" rel="noopener noreferrer">JS transformer<OutboundLink/></a> as an advanced filter. The other transformer can use an external HTTP endpoint to transform events. You can use a local HTTP server, which you host yourself, or a serverless function. The <a href="https://replicator.eventstore.org/docs/features/transforms/http/" target="_blank" rel="noopener noreferrer">HTTP transformer<OutboundLink/></a> allows you to do more advanced transformations, for example, enriching events with data from external sources, like databases.</p>
<p>Practically, you need to run the replicator on your own infrastructure. The primary condition is that the replicator must be able to reach both source and target EventStoreDB clusters. For example, if you replicate from a self-hosted cluster in AWS to Event Store Cloud in AWS, you'd need to peer between the VPC of the self-hosted cluster and the Event Store Cloud network. We provide <a href="https://replicator.eventstore.org/docs/deployment/" target="_blank" rel="noopener noreferrer">detailed instructions<OutboundLink/></a> about running the replicator in Kubernetes and using Docker Compose.</p>
<p>For the cloud migration scenario, the simplest case that involves no filtering (except scavenge) and transformations, you can use the following configuration:</p>
<div class="language-yaml ext-yml line-numbers-mode"><pre v-pre class="language-yaml"><code><span class="token key atrule">replicator</span><span class="token punctuation">:</span>
  <span class="token key atrule">reader</span><span class="token punctuation">:</span>
    <span class="token key atrule">connectionString</span><span class="token punctuation">:</span> ConnectTo=tcp<span class="token punctuation">:</span>//admin<span class="token punctuation">:</span>changeit@my<span class="token punctuation">-</span>instance.acme.company<span class="token punctuation">:</span>1113; HeartBeatTimeout=500; UseSslConnection=false;
    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> tcp
  <span class="token key atrule">sink</span><span class="token punctuation">:</span>
    <span class="token key atrule">connectionString</span><span class="token punctuation">:</span> esdb+discover<span class="token punctuation">:</span>//username<span class="token punctuation">:</span>password@clusterid.mesdb.eventstore.cloud<span class="token punctuation">:</span><span class="token number">2113</span>
    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> grpc
    <span class="token key atrule">partitionCount</span><span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token key atrule">bufferSize</span><span class="token punctuation">:</span> <span class="token number">1000</span>
  <span class="token key atrule">scavenge</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
  <span class="token key atrule">transform</span><span class="token punctuation">:</span> <span class="token null important">null</span>
  <span class="token key atrule">filters</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token key atrule">checkpoint</span><span class="token punctuation">:</span>
    <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">"./checkpoint"</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>As the replication process runs continuously until you stop it, you can test the source cluster data and gradually move read-only workloads to it, like subscriptions. When you confirm that everything looks fine from the target database, you can move all the other workloads to the new cluster.</p>
<p>Find out more about replicator features, limitations, as well as deployment guidelines <a href="https://replicator.eventstore.org/" target="_blank" rel="noopener noreferrer">in the documentation<OutboundLink/></a>.</p>
<p>Disclaimer: Event Store Replicator is an open-source software, provided as-is, without any warranty, and is not covered by Event Store support contract. If you experience an issue when using Replicator, or you'd like to suggest a new feature, please open an issue in the <a href="https://github.com/EventStore/replicator" target="_blank" rel="noopener noreferrer">GitHub project<OutboundLink/></a>.</p>
</template>
